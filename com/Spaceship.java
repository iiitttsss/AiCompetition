/**
 * each spaceship is controlled by an AI. This class keeps all the spaceship related data and updates the spaceship based on the AI's commands
 */
package AiCompetition.com;

import AiCompetition.com.bullets.Bullet;
import AiCompetition.com.bullets.BulletManager;
import AiCompetition.com.commands.ShootCommand;
import AiCompetition.com.commands.ThrustCommand;
import AiCompetition.com.render.CreateSpaceshipSprite;
import processing.core.PImage;

import java.util.ArrayList;

public class Spaceship
{
    public final static float TURNING_MULTIPLIER = 1f;
    public final static float ACCELERATION_MULTIPLIER = 50f;
    public final static float FRICTION_MULTIPLIER = 0.01f;
    public static final int OVERTIME_POINTS_FOR_DEATH = 5;
    private SpaceshipStructure spaceshipStructure;
    private float xPos;
    private float yPos;
    private float xVel;
    private float yVel;
    private float direction;
    private float energy; //the amount of energy the spaceship currently have
    private int hitPoints;
    private PImage spriteBlue;
    private PImage spriteRed;
    private int overTimePoints;//when the AI takes to long to give back command, it will get a point, after a certain amount of points, it losses
    private boolean didCrash;

    public void updateEnergy(float deltaTime)
    {
        this.energy += this.getSpaceshipStructure().getAttribute(UpgradeData.ENERGY_GENERATOR) * deltaTime;
        if (this.getEnergy() > this.getSpaceshipStructure().getAttribute(UpgradeData.BATTERY))
        {
            this.setEnergy(this.getSpaceshipStructure().getAttribute(UpgradeData.BATTERY));
        }
    }

    /**
     * called when hit by a bullet
     *
     * @param bullet - the bullet
     */
    public void hitByBullet(Bullet bullet)
    {
        this.setHitPoints(this.getHitPoints() - bullet.getDamage());
    }

    private SpaceshipStructure covertUpgradeDataToSpaceshipStructure(UpgradeData upgradeData)
    {
        //TODO
        return new SpaceshipStructure(upgradeData);
    }

    /**
     * called before the match begins
     *
     * @param upgradeData - the upgrades of the spaceship as created by the AI
     */
    public void init(UpgradeData upgradeData)
    {
        SpaceshipStructure spaceshipStructure = this.covertUpgradeDataToSpaceshipStructure(upgradeData);
        this.setSpaceshipStructure(spaceshipStructure);
        //this.setDirection((float) (Math.random() * Math.PI * 2));
        this.setxPos((float) (Math.random() * 800 - 400));
        this.setyPos((float) (Math.random() * 800 - 400));
        this.setHitPoints(spaceshipStructure.getAttribute(UpgradeData.HIT_POINTS));

        this.createSprites(upgradeData, spaceshipStructure);
        this.setOverTimePoints(0);
        this.setDidCrash(false);

        //TODO
    }

    /**
     * creates the spaceship sprites according to the upgrades
     *
     * @param upgradeData - the upgrades of the spaceship from the AI
     */
    private void createSprites(UpgradeData upgradeData, SpaceshipStructure spaceshipStructure)
    {
        this.setSpriteBlue(CreateSpaceshipSprite.createSpaceshipSprite(upgradeData, spaceshipStructure, CreateSpaceshipSprite.BLUE_SPRITE));

    }

    /**
     * @param shootCommands - the commands that were generated by the AI
     */
    public void executeShootCommands(ArrayList<ShootCommand> shootCommands, BulletManager bulletManager)
    {
        if (shootCommands == null)
        {
            return;
        }
        int cost = this.calculateShootCommandsCost(shootCommands);
        if (cost > this.getEnergy()) // if all the moves are to0 expensive, do not execute any of them
        {
            return;
        }
        this.energy -= cost;

        // TODO - shoot bullets based on the command
        // IMPORTANT - check if there is enough energy
        for (ShootCommand sc : shootCommands)
        {
            float direction = 0;
            switch (sc.getWhichGun())
            {
                case ShootCommand.FRONT_GUN:
                    direction = this.getDirection();
                    break;
                case ShootCommand.BACK_GUN:
                    direction = (float) (this.getDirection() + Math.PI);
                    break;
                case ShootCommand.LEFT_GUN:
                    direction = (float) (this.getDirection() + 3 * Math.PI / 2);
                    break;
                case ShootCommand.RIGHT_GUN:
                    direction = (float) (this.getDirection() + Math.PI / 2);
                    break;
            }
            float spaceshipSpeed = (float) Math.sqrt(xVel * xVel + yVel * yVel);
            float xVelBasedDirection = (float) (sc.getSpeed() * Math.cos(direction));
            float yVelBasedDirection = (float) (sc.getSpeed() * Math.sin(direction));

            float bulletXVel = xVelBasedDirection + xVel;
            float bulletYVel = yVelBasedDirection + yVel;

            float bulletSpeed = (float) Math.sqrt(bulletXVel * bulletXVel + bulletYVel * bulletYVel);


            bulletManager.addBullet(this, this.getxPos(), this.getyPos(), bulletXVel, bulletYVel, sc.getRadius(), (int) bulletSpeed, sc.getDamage());
        }
    }

    public void updateMovement(float deltaTime)
    {
        this.setxPos(this.getxPos() + deltaTime * this.getxVel());
        this.setyPos(this.getyPos() + deltaTime * this.getyVel());
    }

    /**
     * @param thrustCommands - the list of thrust commands that the AI made
     * @return - calculating the cost of all the thrust commands together
     */
    public int calculateThrustCommandsCost(ArrayList<ThrustCommand> thrustCommands)
    {
        int valueSum = 0;
        for (ThrustCommand tc : thrustCommands)
        {
            valueSum += tc.calculateCost();
        }
        return valueSum;
    }

    /**
     * @param shootCommands - the list of shoot commands that the AI made
     * @return - calculating the cost of all the shoot commands together
     */
    public int calculateShootCommandsCost(ArrayList<ShootCommand> shootCommands)
    {
        int valueSum = 0;
        for (ShootCommand sc : shootCommands)
        {
            valueSum += sc.calculateCost();
        }
        return valueSum;
    }

    /**
     * @param thrustCommands - the commands that were generated by the AI
     */
    public void executeThrustCommands(ArrayList<ThrustCommand> thrustCommands, float deltaTime)
    {
        if (thrustCommands == null)
        {
            return;
        }
        int cost = this.calculateThrustCommandsCost(thrustCommands);
        if (cost > this.getEnergy()) // if all the moves are too expensive, do not execute any of them
        {
            return;
        }
        this.energy -= cost;

        float xAcc = 0;
        float yAcc = 0;
        // TODO - activate thrusters
        // IMPORTANT - check if there is enough energy

        for (ThrustCommand tc : thrustCommands)
        {
            float thrustForce = deltaTime * tc.getForceValue();
            float angle = 0;

            switch (tc.getWhichThruster())
            {
                case ThrustCommand.BACK_THRUSTER:
                    angle = this.getDirection();

                    break;
                case ThrustCommand.FRONT_THRUSTER:
                    angle = (float) (this.getDirection() + Math.PI);
                    xAcc += thrustForce * Math.cos(this.getDirection() + Math.PI);
                    yAcc += thrustForce * Math.sin(this.getDirection() + Math.PI);
                    break;
                case ThrustCommand.RIGHT_THRUSTER:
                    angle = (float) (this.getDirection() - Math.PI / 2);

                    xAcc += thrustForce * Math.cos(this.getDirection() - Math.PI / 2);
                    yAcc += thrustForce * Math.sin(this.getDirection() - Math.PI / 2);
                    break;
                case ThrustCommand.LEFT_THRUSTER:
                    angle = (float) (this.getDirection() + Math.PI / 2);

                    xAcc += thrustForce * Math.cos(this.getDirection() + Math.PI / 2);
                    yAcc += thrustForce * Math.sin(this.getDirection() + Math.PI / 2);
                    break;
                case ThrustCommand.CLOCKWISE_THRUSTER:
                    angle = (this.getDirection() + TURNING_MULTIPLIER * thrustForce);
                    break;
                case ThrustCommand.COUNTER_CLOCKWISE_THRUSTER:
                    angle = (this.getDirection() - TURNING_MULTIPLIER * thrustForce);
                    break;
            }
            switch (tc.getWhichThruster())
            {
                case ThrustCommand.BACK_THRUSTER:
                case ThrustCommand.FRONT_THRUSTER:
                case ThrustCommand.RIGHT_THRUSTER:
                case ThrustCommand.LEFT_THRUSTER:
                    xAcc += thrustForce * Math.cos(angle);
                    yAcc += thrustForce * Math.sin(angle);
                    break;
                case ThrustCommand.CLOCKWISE_THRUSTER:
                case ThrustCommand.COUNTER_CLOCKWISE_THRUSTER:
                    this.setDirection(angle);
                    break;
            }
        }
        this.fixDirection();

        this.setxVel(this.getxVel() + deltaTime * ACCELERATION_MULTIPLIER * xAcc);
        this.setyVel(this.getyVel() + deltaTime * ACCELERATION_MULTIPLIER * yAcc);

        //friction
        float speed = (float) (getxVel() * getxVel() + getyVel() * getyVel());
        float direction = calculateDirectionBasedOnVelocityComponents();

        //this.setDirection(direction);
        this.setxVel((float) (this.getxVel() + deltaTime * FRICTION_MULTIPLIER * speed * Math.cos(direction + Math.PI)));
        this.setyVel((float) (this.getyVel() + deltaTime * FRICTION_MULTIPLIER * speed * Math.sin(direction + Math.PI)));
    }

    private void fixDirection()
    {
        while (this.getDirection() < 0)
        {
            direction += 2 * Math.PI;
        }
        while (this.getDirection() >= 2 * Math.PI)
        {
            direction -= 2 * Math.PI;
        }
    }

    /**
     * @return - calculating the angle from the x and y velocities
     */
    private float calculateDirectionBasedOnVelocityComponents()
    {
        float dx = getxVel();
        float dy = getyVel();
        if (dx == 0)
        {
            if (dy >= 0)
            {
                return (float) (Math.PI / 2);
            } else
            {
                return (float) (3 * Math.PI / 2);
            }
        }
        if (dy == 0)
        {
            if (dx >= 0)
            {
                return 0;
            } else
            {
                return (float) Math.PI;
            }
        }
        float atan = (float) Math.atan(Math.abs(getyVel() / getxVel()));

        if (dx > 0)
        {
            if (dy > 0)
            {
                return atan;//Q1
            } else
            {
                return (float) (2 * Math.PI - atan);//Q4
            }
        } else
        {
            if (dy > 0)
            {
                return (float) (Math.PI - atan);//Q2
            } else
            {
                return (float) (Math.PI + atan);//Q3
            }
        }
    }

    public void handleReflectiveBorders(int xMax, int yMax)
    {
        if (this.getxPos() < 0)
        {
            this.setxPos(this.getxPos() + xMax);
        } else if (this.getxPos() >= xMax)
        {
            this.setxPos(this.getxPos() - xMax);
        } else if (this.getyPos() < 0)
        {
            this.setyPos(this.getyPos() + yMax);
        } else if (this.getyPos() >= yMax)
        {
            this.setyPos(this.getyPos() - yMax);
        }
    }

    /**
     * updates the spaceship
     *
     * @param deltaTime
     */
    public void update(float deltaTime)
    {
        //TODO
    }

    public void addOverTimePoint()
    {
        this.overTimePoints++;
    }

    public boolean isDidCrash()
    {
        return didCrash;
    }

    public void setDidCrash(boolean didCrash)
    {
        this.didCrash = didCrash;
    }

    public int getOverTimePoints()
    {
        return overTimePoints;
    }

    public void setOverTimePoints(int overTimePoints)
    {
        this.overTimePoints = overTimePoints;
    }

    public PImage getSpriteRed()
    {
        return spriteRed;
    }

    public void setSpriteRed(PImage spriteRed)
    {
        this.spriteRed = spriteRed;
    }

    public PImage getSpriteBlue()
    {
        return spriteBlue;
    }

    public void setSpriteBlue(PImage spriteBlue)
    {
        this.spriteBlue = spriteBlue;
    }

    public int getHitPoints()
    {
        return hitPoints;
    }

    public void setHitPoints(int hitPoints)
    {
        this.hitPoints = hitPoints;
    }

    public float getEnergy()
    {
        return energy;
    }

    public void setEnergy(float energy)
    {
        this.energy = energy;
    }

    public SpaceshipStructure getSpaceshipStructure()
    {
        return spaceshipStructure;
    }

    public void setSpaceshipStructure(SpaceshipStructure spaceshipStructure)
    {
        this.spaceshipStructure = spaceshipStructure;
    }


    public float getxPos()
    {
        return xPos;
    }

    public void setxPos(float xPos)
    {
        this.xPos = xPos;
    }

    public float getyPos()
    {
        return yPos;
    }

    public void setyPos(float yPos)
    {
        this.yPos = yPos;
    }

    public float getxVel()
    {
        return xVel;
    }

    public void setxVel(float xVel)
    {
        this.xVel = xVel;
    }

    public float getyVel()
    {
        return yVel;
    }

    public void setyVel(float yVel)
    {
        this.yVel = yVel;
    }

    public float getDirection()
    {
        return direction;
    }

    public void setDirection(float direction)
    {
        this.direction = direction;
    }
}
