/**
 * each spaceship is controlled by an AI. This class keeps all the spaceship related data and updates the spaceship based on the AI's commands
 */
package AiCompetition.com;

import AiCompetition.com.bullets.Bullet;
import AiCompetition.com.bullets.BulletManager;
import AiCompetition.com.commands.ShootCommand;
import AiCompetition.com.commands.ThrustCommand;
import AiCompetition.com.render.CreateSpaceshipSprite;
import processing.core.PImage;

import java.util.ArrayList;

public class Spaceship
{
    public final static float TURNING_MULTIPLIER = 0.01f;
    public final static float ACCELERATION_MULTIPLIER = 0.01f;
    public final static float FRICTION_MULTIPLIER = 0.001f;
    private SpaceshipStructure spaceshipStructure;
    private float xPos;
    private float yPos;
    private float xVel;
    private float yVel;
    private float direction;
    private int energy; //the amount of energy the spaceship currently have
    private int hitPoints;
    private PImage spriteBlue;


    public void updateEnergy()
    {
        this.energy += this.getSpaceshipStructure().getEnergyPerTurn();
        if (this.getEnergy() > this.getSpaceshipStructure().getMaxEnergy())
        {
            this.setEnergy(this.getSpaceshipStructure().getMaxEnergy());
        }
    }

    /**
     * called when hit by a bullet
     *
     * @param bullet - the bullet
     */
    public void hitByBullet(Bullet bullet)
    {
        this.setHitPoints(this.getHitPoints() - bullet.getDamage());
    }

    private SpaceshipStructure covertUpgradeDataToSpaceshipStructure(UpgradeData upgradeData)
    {
        //TODO
        return new SpaceshipStructure(upgradeData);
    }
    /**
     * called before the match begins
     *
     * @param upgradeData - the upgrades of the spaceship as created by the AI
     */
    public void init(UpgradeData upgradeData)
    {
        SpaceshipStructure spaceshipStructure = this.covertUpgradeDataToSpaceshipStructure(upgradeData);
        this.setSpaceshipStructure(spaceshipStructure);
        this.setSpriteBlue(CreateSpaceshipSprite.createSpaceshipSprite(spaceshipStructure));
        //this.setDirection((float) (Math.random() * Math.PI * 2));
        this.setxPos((float) (Math.random() * 800 - 400));
        this.setyPos((float) (Math.random() * 800 - 400));
        this.setHitPoints(spaceshipStructure.getMaxHitPoints());
        //TODO
    }

    /**
     * @param shootCommands - the commands that were generated by the AI
     */
    public void executeShootCommands(ArrayList<ShootCommand> shootCommands, BulletManager bulletManager)
    {
        int cost = this.calculateShootCommandsCost(shootCommands);
        if (cost > this.getEnergy()) // if all the moves are to expensive, do not execute any of them
        {
            return;
        }
        this.energy -= cost;

        // TODO - shoot bullets based on the command
        // IMPORTANT - check if there is enough energy
        for (ShootCommand sc : shootCommands)
        {
            float direction = 0;
            switch (sc.getWhichGun())
            {
                case ShootCommand.FRONT_GUN:
                    direction = this.getDirection();
                    break;
                case ShootCommand.BACK_GUN:
                    direction = (float) (this.getDirection() + Math.PI);
                    break;
                case ShootCommand.LEFT_GUN:
                    direction = (float) (this.getDirection() + 3 * Math.PI / 2);
                    break;
                case ShootCommand.RIGHT_GUN:
                    direction = (float) (this.getDirection() + Math.PI / 2);
                    break;
            }
            float spaceshipSpeed = (float) Math.sqrt(xVel * xVel + yVel * yVel);
            float xVelBasedDirection = (float) (sc.getSpeed() * Math.cos(direction));
            float yVelBasedDirection = (float) (sc.getSpeed() * Math.sin(direction));

            float bulletXVel = xVelBasedDirection + xVel;
            float bulletYVel = yVelBasedDirection + yVel;

            float bulletSpeed = (float) Math.sqrt(bulletXVel * bulletXVel + bulletYVel * bulletYVel);


            bulletManager.addBullet(this, this.getxPos(), this.getyPos(), bulletXVel, bulletYVel, sc.getRadius(), (int) bulletSpeed, sc.getDamage());
        }
    }

    public void updateMovement()
    {
        this.setxPos(this.getxPos() + this.getxVel());
        this.setyPos(this.getyPos() + this.getyVel());
    }

    /**
     * @param thrustCommands - the list of thrust commands that the AI made
     * @return - calculating the cost of all the thrust commands together
     */
    public int calculateThrustCommandsCost(ArrayList<ThrustCommand> thrustCommands)
    {
        int valueSum = 0;
        for (ThrustCommand tc : thrustCommands)
        {
            valueSum += tc.calculateCost();
        }
        return valueSum;
    }

    /**
     * @param shootCommands - the list of shoot commands that the AI made
     * @return - calculating the cost of all the shoot commands together
     */
    public int calculateShootCommandsCost(ArrayList<ShootCommand> shootCommands)
    {
        int valueSum = 0;
        for (ShootCommand sc : shootCommands)
        {
            valueSum += sc.calculateCost();
        }
        return valueSum;
    }

    /**
     * @param thrustCommands - the commands that were generated by the AI
     */
    public void executeThrustCommands(ArrayList<ThrustCommand> thrustCommands)
    {
        int cost = this.calculateThrustCommandsCost(thrustCommands);
        if (cost > this.getEnergy()) // if all the moves are to expensive, do not execute any of them
        {
            return;
        }
        this.energy -= cost;

        float xAcc = 0;
        float yAcc = 0;
        // TODO - activate thrusters
        // IMPORTANT - check if there is enough energy

        for (ThrustCommand tc : thrustCommands)
        {
            switch (tc.getWhichThruster())
            {
                case ThrustCommand.BACK_THRUSTER:
                    xAcc += tc.getForceValue() * Math.cos(this.getDirection());
                    yAcc += tc.getForceValue() * Math.sin(this.getDirection());
                    break;
                case ThrustCommand.FRONT_THRUSTER:
                    xAcc += tc.getForceValue() * Math.cos(this.getDirection() + Math.PI);
                    yAcc += tc.getForceValue() * Math.sin(this.getDirection() + Math.PI);
                    break;
                case ThrustCommand.RIGHT_THRUSTER:
                    xAcc += tc.getForceValue() * Math.cos(this.getDirection() - Math.PI / 2);
                    yAcc += tc.getForceValue() * Math.sin(this.getDirection() - Math.PI / 2);
                    break;
                case ThrustCommand.LEFT_THRUSTER:
                    xAcc += tc.getForceValue() * Math.cos(this.getDirection() + Math.PI / 2);
                    yAcc += tc.getForceValue() * Math.sin(this.getDirection() + Math.PI / 2);
                    break;
                case ThrustCommand.CLOCKWISE_THRUSTER:
                    this.setDirection(this.getDirection() + TURNING_MULTIPLIER * tc.getForceValue());
                    break;
                case ThrustCommand.COUNTER_CLOCKWISE_THRUSTER:
                    this.setDirection(this.getDirection() - TURNING_MULTIPLIER * tc.getForceValue());
                    break;
            }
        }

        this.setxVel(this.getxVel() + ACCELERATION_MULTIPLIER * xAcc);
        this.setyVel(this.getyVel() + ACCELERATION_MULTIPLIER * yAcc);

        //friction
        float speed = (float) (getxVel() * getxVel() + getyVel() * getyVel());
        float direction = calculateDirectionBasedOnVelocityComponents();

        //this.setDirection(direction);
        this.setxVel((float) (this.getxVel() + FRICTION_MULTIPLIER * speed * Math.cos(direction + Math.PI)));
        this.setyVel((float) (this.getyVel() + FRICTION_MULTIPLIER * speed * Math.sin(direction + Math.PI)));
    }

    /**
     * @return - calculating the angle from the x and y velocities
     */
    private float calculateDirectionBasedOnVelocityComponents()
    {
        float dx = getxVel();
        float dy = getyVel();
        if (dx == 0)
        {
            if (dy >= 0)
            {
                return (float) (Math.PI / 2);
            } else
            {
                return (float) (3 * Math.PI / 2);
            }
        }
        if (dy == 0)
        {
            if (dx >= 0)
            {
                return 0;
            } else
            {
                return (float) Math.PI;
            }
        }
        float atan = (float) Math.atan(Math.abs(getyVel() / getxVel()));

        if (dx > 0)
        {
            if (dy > 0)
            {
                return atan;//Q1
            } else
            {
                return (float) (2 * Math.PI - atan);//Q4
            }
        } else
        {
            if (dy > 0)
            {
                return (float) (Math.PI - atan);//Q2
            } else
            {
                return (float) (Math.PI + atan);//Q3
            }
        }
    }

    public void handleReflectiveBorders(int xMax, int yMax)
    {
        if (this.getxPos() < 0)
        {
            this.setxPos(this.getxPos() + xMax);
        } else if (this.getxPos() >= xMax)
        {
            this.setxPos(this.getxPos() - xMax);
        } else if (this.getyPos() < 0)
        {
            this.setyPos(this.getyPos() + yMax);
        } else if (this.getyPos() >= yMax)
        {
            this.setyPos(this.getyPos() - yMax);
        }
    }

    /**
     * updates the spaceship
     *
     * @param deltaTime
     */
    public void update(float deltaTime)
    {
        //TODO
    }

    public PImage getSpriteBlue()
    {
        return spriteBlue;
    }

    public void setSpriteBlue(PImage spriteBlue)
    {
        this.spriteBlue = spriteBlue;
    }

    public int getHitPoints()
    {
        return hitPoints;
    }

    public void setHitPoints(int hitPoints)
    {
        this.hitPoints = hitPoints;
    }

    public int getEnergy()
    {
        return energy;
    }

    public void setEnergy(int energy)
    {
        this.energy = energy;
    }

    public SpaceshipStructure getSpaceshipStructure()
    {
        return spaceshipStructure;
    }

    public void setSpaceshipStructure(SpaceshipStructure spaceshipStructure)
    {
        this.spaceshipStructure = spaceshipStructure;
    }


    public float getxPos()
    {
        return xPos;
    }

    public void setxPos(float xPos)
    {
        this.xPos = xPos;
    }

    public float getyPos()
    {
        return yPos;
    }

    public void setyPos(float yPos)
    {
        this.yPos = yPos;
    }

    public float getxVel()
    {
        return xVel;
    }

    public void setxVel(float xVel)
    {
        this.xVel = xVel;
    }

    public float getyVel()
    {
        return yVel;
    }

    public void setyVel(float yVel)
    {
        this.yVel = yVel;
    }

    public float getDirection()
    {
        return direction;
    }

    public void setDirection(float direction)
    {
        this.direction = direction;
    }
}
