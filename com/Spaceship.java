/**
 * each spaceship is controlled by an AI. This class keeps all the spaceship related data and updates the spaceship based on the AI's commands
 */
package AiCompetition.com;

import AiCompetition.com.commands.ShootCommand;
import AiCompetition.com.commands.ThrustCommand;

import java.util.ArrayList;

public class Spaceship
{
    private SpaceshipStructure structure;
    private float xPos;
    private float yPos;
    private float xVel;
    private float yVel;
    private float direction;
    private int energy; //the amount of energy the spaceship currently have

    public final static float TURNING_MULTIPLIER = 0.01f;
    public final static float ACCELERATION_MULTIPLIER = 0.01f;
    public final static float FRICTION_MULTIPLIER = 0.001f;



    /**
     * called before the match begins
     *
     * @param structure - the structure of the spaceship as created by the AI
     */
    public void init(SpaceshipStructure structure)
    {
        this.setStructure(structure);
        //this.setDirection((float) (Math.random() * Math.PI * 2));
        this.setxPos(400);
        this.setyPos(400);
        //TODO
    }

    /**
     * @param shootCommands - the commands that were generated by the AI
     */
    public void executeShootCommands(ArrayList<ShootCommand> shootCommands)
    {
        // TODO - shoot bullets based on the command
        // IMPORTANT - check if there is enough energy
    }

    public void updateMovement()
    {
        this.setxPos(this.getxPos() + this.getxVel());
        this.setyPos(this.getyPos() + this.getyVel());
    }

    /**
     * @param thrustCommands - the commands that were generated by the AI
     */
    public void executeThrustCommands(ArrayList<ThrustCommand> thrustCommands)
    {
        float xAcc = 0;
        float yAcc = 0;
        // TODO - activate thrusters
        // IMPORTANT - check if there is enough energy

        for (ThrustCommand tc : thrustCommands) {
            switch (tc.getWhichThruster()) {
                case ThrustCommand.BACK_THRUSTER:
                    xAcc += tc.getForceValue() * Math.cos(this.getDirection());
                    yAcc += tc.getForceValue() * Math.sin(this.getDirection());
                    break;
                case ThrustCommand.FRONT_THRUSTER:
                    xAcc += tc.getForceValue() * Math.cos(this.getDirection() + Math.PI);
                    yAcc += tc.getForceValue() * Math.sin(this.getDirection() + Math.PI);
                    break;
                case ThrustCommand.RIGHT_THRUSTER:
                    xAcc += tc.getForceValue() * Math.cos(this.getDirection() - Math.PI / 2);
                    yAcc += tc.getForceValue() * Math.sin(this.getDirection() - Math.PI / 2);
                    break;
                case ThrustCommand.LEFT_THRUSTER:
                    xAcc += tc.getForceValue() * Math.cos(this.getDirection() + Math.PI / 2);
                    yAcc += tc.getForceValue() * Math.sin(this.getDirection() + Math.PI / 2);
                    break;
                case ThrustCommand.CLOCKWISE_THRUSTER:
                        this.setDirection(this.getDirection() + TURNING_MULTIPLIER * tc.getForceValue());
                    break;
                case ThrustCommand.COUNTER_CLOCKWISE_THRUSTER:
                    this.setDirection(this.getDirection() - TURNING_MULTIPLIER * tc.getForceValue());
                    break;
            }
        }

        this.setxVel(this.getxVel() + ACCELERATION_MULTIPLIER * xAcc);
        this.setyVel(this.getyVel() + ACCELERATION_MULTIPLIER * yAcc);

        //friction
        float speed = (float) (getxVel() * getxVel() + getyVel() * getyVel());
        float direction = calculateDirectionBasedOnVelocityComponents();
        //System.out.println(this.getDirection() + " | " + direction);

        System.out.println(speed);
        //this.setDirection(direction);
        this.setxVel((float) (this.getxVel() + FRICTION_MULTIPLIER * speed * Math.cos(direction + Math.PI)));
        this.setyVel((float) (this.getyVel() + FRICTION_MULTIPLIER * speed * Math.sin(direction + Math.PI)));


    }

    /**
     * @return - calculating the angle from the x and y velocities
     */
    private float calculateDirectionBasedOnVelocityComponents()
    {
        float dx = getxVel();
        float dy = getyVel();
        if (dx == 0) {
            if (dy >= 0) {
                return (float) (Math.PI / 2);
            } else {
                return (float) (3 * Math.PI / 2);
            }
        }
        if (dy == 0) {
            if (dx >= 0) {
                return 0;
            } else {
                return (float) Math.PI;
            }
        }
        float atan = (float) Math.atan(Math.abs(getyVel() / getxVel()));

        if (dx > 0) {
            if (dy > 0) {
                return atan;//Q1
            } else {
                return (float) (2 * Math.PI - atan);//Q4
            }
        } else {
            if (dy > 0) {
                return (float) (Math.PI - atan);//Q2
            } else {
                return (float) (Math.PI + atan);//Q3
            }
        }
    }


    public void handleReflectiveBorders(int xMax, int yMax)
    {
        if (this.getxPos() < 0) {
            this.setxPos(this.getxPos() + xMax);
        } else if (this.getxPos() >= xMax) {
            this.setxPos(this.getxPos() - xMax);
        } else if (this.getyPos() < 0) {
            this.setyPos(this.getyPos() + yMax);
        } else if (this.getyPos() >= yMax) {
            this.setyPos(this.getyPos() - yMax);
        }
    }

    /**
     * updates the spaceship
     *
     * @param deltaTime
     */
    public void update(float deltaTime)
    {
        //TODO
    }

    public int getEnergy()
    {
        return energy;
    }

    public void setEnergy(int energy)
    {
        this.energy = energy;
    }

    public SpaceshipStructure getStructure()
    {
        return structure;
    }

    public void setStructure(SpaceshipStructure structure)
    {
        this.structure = structure;
    }

    public float getxPos()
    {
        return xPos;
    }

    public void setxPos(float xPos)
    {
        this.xPos = xPos;
    }

    public float getyPos()
    {
        return yPos;
    }

    public void setyPos(float yPos)
    {
        this.yPos = yPos;
    }

    public float getxVel()
    {
        return xVel;
    }

    public void setxVel(float xVel)
    {
        this.xVel = xVel;
    }

    public float getyVel()
    {
        return yVel;
    }

    public void setyVel(float yVel)
    {
        this.yVel = yVel;
    }

    public float getDirection()
    {
        return direction;
    }

    public void setDirection(float direction)
    {
        this.direction = direction;
    }
}
